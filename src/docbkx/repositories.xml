<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="repositories">
  <title>Working with Spring Data Repositories</title>

  <para><!--** BT: I commented the following because the logic is a little confusing, and it might be better to just start with the goal
of the project; see sentence below. Presumably readers know the traditional problems. [[Questions re following: 
second sentence; using *which* technologies made life easier? object-oriented and domain-driven? But first sentence 
said domain classes were *not* designed this way. --><!--Implementing a data access layer of an application has been cumbersome for quite a while. Too much
boilerplate code had to be written. Domain classes were anemic and not designed in a real object oriented or
domain driven manner.Using both of these technologies makes developers life a lot easier regarding rich domain model's persistence.
Nevertheless the amount of boilerplate code to implement repositories especially is still quite high. -->The
  goal of Spring Data repository abstraction is to significantly reduce the
  amount of boilerplate code required to implement data access layers for
  various persistence stores.</para>

  <section id="repositories.introduction">
    <title>Important: Spring Data repository documentation and your
    module</title>

    <para>This chapter, "Working with Spring Data Repositories," explains the
    core concepts and interfaces of Spring Data repositories. The information
    in this chapter is pulled from Spring Data Commons. It uses the
    configuration and code samples for the Java Persistence API (JPA) module.
    Adapt the XML namespace declaration and the types to be extended to the
    equivalents of the particular module that you are using. Appendix A
    "Namespace Reference" and Appendix B "Repository Query Keywords" also
    contain information that applies to all Spring Data repositories.<!--BT, need to clarify what parts of appendixes apply to all.-->For
    detailed information on the specific features of your module, consult the
    chapter on that module. of this document.<!--BT Are Appendix C FAQS and Glossary module specific? If so add that.--></para>
  </section>

  <section id="repositories.core-concepts">
    <title>Core concepts</title>

    <para>The central interface in Spring Data repository abstraction is
    <interfacename>Repository</interfacename> (probably not that much of a
    surprise). It is typeable to the domain class to manage as well as the id
    type of the domain class.<!--BT Previous sentence is somewhat garbled, wording doesn't track. Reword to clarify? -->This
    interface acts primarily as a marker interface to capture the types to
    work with and to help you to discover interfaces that extend this one. The
    <interfacename>CrudRepository</interfacename> provides sophisticated CRUD
    functionality for the entity<!--BT By entity clarify whether you mean module, like JPA, or something else.-->
    being managed.</para>

    <example id="repositories.repository">
      <title><interfacename>CrudRepository</interfacename> interface</title>

      <programlistingco>
        <areaspec>
          <area coords="3" id="repository.save"/>

          <area coords="5" id="repository.find-by-id"/>

          <area coords="7" id="repository.find-all"/>

          <area coords="11" id="repository.count"/>

          <area coords="13" id="repository.delete"/>

          <area coords="15" id="repository.exists"/>
        </areaspec>

        <programlisting language="java">public interface CrudRepository&lt;T, ID extends Serializable&gt;
    extends Repository&lt;T, ID&gt; {

    &lt;S extends T&gt; S save(S entity);

    T findOne(ID primaryKey);

    Iterable&lt;T&gt; findAll();

    Long count();

    void delete(T entity);

    boolean exists(ID primaryKey);

    // … more functionality omitted.
}</programlisting>

        <calloutlist>
          <callout arearefs="repository.save">
            <para>Saves the given entity.</para>
          </callout>

          <callout arch="" arearefs="repository.find-by-id">
            <para>Returns the entity identified by the given id.</para>
          </callout>

          <callout arearefs="repository.find-all">
            <para>Returns all entities.</para>
          </callout>

          <callout arearefs="repository.count">
            <para>Returns the number of entities.</para>
          </callout>

          <callout arearefs="repository.delete">
            <para>Deletes the given entity.</para>
          </callout>

          <callout arearefs="repository.exists">
            <para>Indicates whether an entity with the given id exists.</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </example>

    <para>Persistence technology sub-interfaces include additional
    technology-specific methods. Spring ships implementations for a variety of
    Spring Data modules that implement this interface.<!--BT previous: Indicate: that implement *which* interface? CrudRepository? --></para>

    <para>On top of the <interfacename>CrudRepository</interfacename> there is
    a <interfacename>PagingAndSortingRepository</interfacename> abstraction
    that adds additional methods to ease paginated access to entities:</para>

    <example>
      <title>PagingAndSortingRepository</title>

      <programlisting language="java">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; {

    Iterable&lt;T&gt; findAll(Sort sort);

    Page&lt;T&gt; findAll(Pageable pageable);
}</programlisting>
    </example>

    <para>Accessing the second page of <classname>User</classname> by a page
    size of 20 you could simply do something like this:<!--BT What do you mean, *by a page **size** of 20*? Do you mean on page 20? Is this clear?
 What are you accomplishing in this example?--></para>

    <programlisting language="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</programlisting>
  </section>

  <section id="repositories.query-methods">
    <title>Query methods</title>

    <para>Standard CRUD functionality repositories usually have queries on the
    underlying datastore. With Spring Data, declaring those queries becomes a
    four-step process:</para>

    <orderedlist>
      <listitem>
        <para>Declare an interface extending
        <interfacename>Repository</interfacename> or one of its subinterfaces
        and type it to the domain class that it will handle.</para>

        <programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; { … }</programlisting>
      </listitem>

      <listitem>
        <para>Declare query methods on the interface.</para>

        <programlisting language="java">List&lt;Person&gt; findByLastname(String lastname);</programlisting>
      </listitem>

      <listitem>
        <para>Set up Spring to create proxy instances for those
        interfaces.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</programlisting>

        <note>
          <para>The JPA namespace is used in this example. If you are using
          the repository abstraction for any other store, you need to change
          this to the appropriate namespace declaration of your store module
          which should be exchanging <code>jpa</code> in favor of, for
          example, <code>mongodb</code>.</para>
        </note>
      </listitem>

      <listitem>
        <para>Get the repository instance injected and use it.<!--BT preceding; does this show repository instance being injected? Do you need to explain any of what is going
on in this example? --></para>

        <programlisting language="java">public class SomeClient {

  @Autowired
  private PersonRepository repository;

  public void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
  }</programlisting>
      </listitem>
    </orderedlist>

    <para>The sections that follow explain each step.</para>

    <section id="repositories.definition">
      <title>Defining repository interfaces</title>

      <para>As a first step you define a domain class-specific repository
      interface. The interface must extend
      <interfacename>Repository</interfacename> and be typed to the domain
      class and an ID type. If you want to expose CRUD methods for that domain
      type, extend <interfacename>CrudRepository</interfacename> instead of
      <interfacename>Repository</interfacename>.</para>

      <section id="repositories.definition-tuning">
        <title>Fine-tuning repository definition</title>

        <para>Typically, your repository interface will extend
        <interfacename>Repository</interfacename>,
        <interfacename>CrudRepository</interfacename> or
        <interfacename>PagingAndSortingRepository</interfacename>.<!--BT Clarify: If next sentence refers to an *alternative* to what you do in first sentence, revise to say
 *Alternatively, if you do not want to extend Spring Data interfaces, you can annotate your repository interface* etc. 
Delete *also*. If you mean

*in addition*, revise to say *In addition, if you do not want to extend etc.,you can also"-->If
        you do not want to extend Spring Data interfaces, you can also
        annotate your repository interface with
        <interfacename>@RepositoryDefinition</interfacename>.<!--BT Preceding, where is an example of annotating with @RepositoryDefinition? If preceding is an alternative to what you do in

first sentence, I would move it after the info about extending Repository, CrudRep, etc.-->
        Extending <interfacename>CrudRepository</interfacename> exposes a
        complete set of methods to manipulate your entities. If you prefer to
        be selective about the methods being exposed, simply copy the ones you
        want to expose from <interfacename>CrudRepository</interfacename> into
        your domain repository.</para>

        <example>
          <title>Selectively exposing CRUD methods</title>

          <programlisting language="java">interface MyBaseRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {
  T findOne(ID id);
  T save(T entity);
}

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {

  User findByEmailAddress(EmailAddress emailAddress);
}</programlisting>
        </example>

        <para>In this first step you defined a common base interface for all
        your domain repositories and exposed
        <methodname>findOne(…)</methodname> as well as
        <methodname>save(…)</methodname>.These methods will be routed into the
        base repository implementation of the store of your choice <!--BT preceding, do you  need to say at what point you designate the store?-->because
        they are matching the method signatures in
        <interfacename>CrudRepository</interfacename>. So the
        <interfacename>UserRepository</interfacename> will now be able to save
        users, and find single ones by id, as well as triggering a query to
        find <interfacename>User</interfacename>s by their email
        address.</para>
      </section>
    </section>

    <section id="repositories.query-methods.details">
      <title>Defining query methods</title>

      <para>The repository proxy has two ways to derive a store-specific query
      from the method name. It can derive the query from the method name
      directly, or by using an additionally created query. Available options
      depend on the actual store. However, there's got to be an algorithm that
      decides what actual query is created.<!--BT Does last sentence mean There *is* an algorithm that determines the query that is created? --></para>

      <section id="repositories.query-methods.query-lookup-strategies">
        <title>Query lookup strategies</title>

        <para>The following strategies are available for the repository
        infrastructure to resolve the query. You can configure the strategy at
        the namespace through the <code>query-lookup-strategy</code>
        attribute. Some strategies may not be supported for particular
        datastores.</para>

        <simplesect>
          <title>CREATE</title>

          <para><code>CREATE</code> attempts to construct a store-specific
          query from the query method name. The general approach is to remove
          a given set of well-known prefixes from the method name and parse
          the rest of the method. Read more about query construction in <xref
          linkend="repositories.query-methods.query-creation"/>.</para>
        </simplesect>

        <simplesect>
          <title>USE_DECLARED_QUERY</title>

          <para><code>USE_DECLARED_QUERY</code> tries to find a declared
          query<!-- which will be used for execution first-->. <!--BT Put in comment because it is confusing in this context. CREATE_IF_NOT_FOUND looks up USE_DECLARED_QUERY first but
 doesn't make sense to say that here when it's talking about only using USE_DECLARED_QUERY. -->The
          query can be defined by an annotation somewhere or declared by other
          means. Consult the documentation of the specific store to find
          available options for that store. If the repository infrastructure
          does not find a declared query for the method at bootstrap time, it
          fails.</para>
        </simplesect>

        <simplesect>
          <title>CREATE_IF_NOT_FOUND (default)</title>

          <para><code>CREATE_IF_NOT_FOUND</code> combines <code>CREATE</code>
          and <code>USE_DECLARED_QUERY</code>. It looks up a declared query
          first, and if no declared query is found, it creates a custom method
          name-based query. This is the default lookup strategy and thus will
          be used if you do not configure anything explicitly. It allows quick
          query definition by method names but also custom-tuning of these
          queries by introducing declared queries as needed.</para>
        </simplesect>
      </section>

      <section id="repositories.query-methods.query-creation">
        <title>Query creation</title>

        <para>The query builder mechanism built into Spring Data repository
        infrastructure is useful for building constraining queries over
        entities of the repository. The mechanism strips the prefixes
        <code>find…By</code>, <code>read…By</code>, and <code>get…By</code>
        from the method and starts parsing the rest of it. The introducing
        clause can contain further expressions such as a <code>Distinct</code>
        to set a distinct flag on the query to be created. However, the first
        <code>By</code> acts as delimiter to indicate the start of the actual
        criteria. At a very basic level you can define conditions on entity
        properties and concatenate them with <code>AND</code> and
        <code>OR</code>.</para>

        <example>
          <title>Query creation from method names</title>

          <para><programlisting language="java">public interface PersonRepository extends Repository&lt;User, Long&gt; {

  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}</programlisting></para>
        </example>

        <para>The actual result of parsing the method depends on the
        persistence store for which you create the query. However, there are
        some general things to notice. <itemizedlist>
            <listitem>
              <para>The expressions are usually property traversals combined
              with operators that can be concatenated. You can combine
              property expressions with <code>AND</code> and <code>OR</code>.
              You also get support for operators such as
              <literal>Between</literal>, <literal>LessThan</literal>,
              <literal>GreaterThan</literal>, <literal>Like</literal> for the
              property expressions. The supported operators can vary by
              datastore, so consult the appropriate part of your reference
              documentation.</para>
            </listitem>

            <listitem>
              <para>The method parser supports setting an
              <code>IgnoreCase</code> flag for individual properties, for
              example,<methodname>findByLastnameIgnoreCase(…)</methodname>) or
              for all properties of a type that support ignoring case (usually
              <code>String</code>s, for example,
              <methodname>findByLastnameAndFirstnameAllIgnoreCase(…)</methodname>).
              Whether ignoring cases is supported may vary by store, so
              consult the relevant sections in the reference documentation for
              the store-specific query method.</para>
            </listitem>

            <listitem>
              <para>You can apply static ordering by appending an
              <code>OrderBy</code> clause to the query method that references
              a property and by providing a sorting direction
              (<code>Asc</code> or <code>Desc</code>). To create a query
              method that supports dynamic sorting, see <xref
              linkend="repositories.special-parameters"/>.</para>
            </listitem>
          </itemizedlist></para>
      </section>

      <section>
        <title>Property expressions</title>

        <para>Property expressions can refer only to a direct property of the
        managed entity, as shown in the preceding example. At query creation
        time you already make sure that the parsed property is a property of
        the managed domain class. However, you can also define constraints by
        traversing nested properties. Assume <classname>Person</classname>s
        have <classname>Address</classname>es with
        <classname>ZipCode</classname>s. In that case a method name of</para>

        <programlisting language="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</programlisting>

        <para>creates the property traversal <code>x.address.zipCode</code>.
        The resolution algorithm starts with interpreting the entire part
        (<literal>AddressZipCode</literal>) as the property and checks the
        domain class for a property with that name (uncapitalized). If the
        algorithm succeeds it uses that property. If not, the algorithm splits
        up the source at the camel case parts from the right side into a head
        and a tail and tries to find the corresponding property, for example,
        <literal>AddressZip</literal> and <literal>Code</literal>. If you find
        a property with that head we take the tail <!--BT What do you mean you take the tail; what are you doing? Or does algorithm do this?-->and
        continue building the tree down from there. If the first split does
        not match, we <!--BT Revise preceding to clarify whether a human (in which case, *you*, not *we*) moves the split point, or does the algorithm

do it. i.e. clarify whether this is a manual task? Preceding sentences refer to algorithm.-->move
        the split point to the left (<literal>Address</literal>,
        <literal>ZipCode</literal>).<!--BT The previous three sentences are not very clear; can you reword?--></para>

        <para>Although this should work for most cases, it is possible for the
        algorithm to select the wrong property. Suppose the
        <classname>Person</classname> class has an <code>addressZip</code>
        property as well. The algorithm would match in the first split round
        already<!--BT why would it match? the first split capitalizes Address.-->
        and essentially choose the wrong property and finally fail (as the
        type of <classname>addressZip</classname> probably has no code
        property). <!--BT why would it choose the wrong property if it matches? Does this paragraph need clarification?-->To
        resolve this ambiguity you can use <literal>_</literal> inside your
        method name to manually define traversal points. So our method name
        would end up like so:</para>

        <programlisting language="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
</programlisting>
      </section>

      <section id="repositories.special-parameters">
        <title>Special parameter handling</title>

        <para>To handle parameters to your query you simply define method
        parameters as already seen in the examples above. Besides that we will
        recognize certain specific types to apply pagination and sorting to
        your queries dynamically.<!--BT Revise *we* will recognize. Are you talking about something that is done automatically? I would reword. And identify the
*specific types*?--></para>

        <example>
          <title>Using Pageable and Sort in query methods</title>

          <programlisting>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</programlisting>
        </example>

        <para>The first method allows you to pass an
        <code>org.springframework.data.domain.Pageable</code> instance to the
        query method to dynamically add paging to your statically defined
        query. Sorting options are handled through the
        <interfacename>Pageable</interfacename> instance too. If you only need
        sorting, simply add an
        <code>org.springframework.data.domain.Sort</code> parameter to your
        method. As you also can see, simply returning a
        <interfacename>List</interfacename> is possible as well. The example
        does not retrieve the additional metadata required to build the actual
        <interfacename>Page</interfacename> instance but rather simply
        restricts the query to look up only the given range of entities.<!--BT revised *we* to *the example*. OK? Clarify what you're referring to. --></para>

        <note>
          <para>To find out how many pages you get for a query entirely you
          have to trigger an additional count query. By default this query
          will be derived from the query you actually trigger.</para>
        </note>
      </section>
    </section>

    <section id="repositories.create-instances">
      <title>Creating repository instances</title>

      <para>In this section you create instances and bean definitions for the
      repository interfaces defined. The easiest way to do so is by using the
      Spring namespace that is shipped with each Spring Data module that
      supports the repository mechanism.</para>

      <section id="repositories.create-instances.spring">
        <title>XML configuration</title>

        <para>Each Spring Data module includes a repositories element that
        allows you to simply define a base package that Spring scans for
        you.</para>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans:beans&gt;</programlisting>

        <para>In the preceding example, Spring is instructed to scan
        <package>com.acme.repositories</package> and all its subpackages for
        interfaces extending <interfacename>Repository</interfacename> or one
        of its subinterfaces. For each interface found, Spring registers the
        persistence technology-specific
        <interfacename>FactoryBean</interfacename> to create the appropriate
        proxies that handle invocations of the query methods. Each bean is
        registered under a bean name that is derived from the interface name,
        so an interface of <interfacename>UserRepository</interfacename> would
        be registered under <code>userRepository</code>. The
        <code>base-package</code> attribute allowswildcards, so that you can
        have a pattern of scanned packages.</para>

        <simplesect>
          <title>Using filters</title>

          <para>By default Spring picks up every interface extending the
          persistence technology-specific
          <interfacename>Repository</interfacename> subinterface located under
          the configured base package and creates a bean instance for it.
          However, you might want more fine-grained control over which
          interfaces bean instances get created for. To do this you use
          <code>&lt;include-filter /&gt;</code> and <code>&lt;exclude-filter
          /&gt;</code> elements inside <code>&lt;repositories /&gt;</code>.
          The semantics are exactly equivalent to the elements in Spring's
          context namespace. For details, see <ulink
          url="http://static.springsource.org/spring/docs/2.5.x/reference/beans.html#beans-scanning-filters"
          vendor="">Spring reference documentation</ulink> on these
          elements.</para>

          <para>For example, to exclude certain interfaces from instantiation
          as repository, you could use the following configuration:</para>

          <example>
            <title>Using exclude-filter element</title>

            <programlisting language="xml">&lt;repositories base-package="com.acme.repositories"&gt;
  &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
&lt;/repositories&gt;</programlisting>

            <para>This example excludes all interfaces ending in
            <interfacename>SomeRepository</interfacename> from being
            instantiated.</para>
          </example>
        </simplesect>
      </section>

      <section id="repositories.create-instances.java-config">
        <title>JavaConfig</title>

        <para>The repository infrastructure can also be triggered using a
        store-specific
        <interfacename>@Enable${store}Repositories</interfacename> annotation
        on a JavaConfig class. For an introduction into Java-based
        configuration of the Spring container, see the reference
        documentation.<footnote>
            <para>JavaConfig in the Spring reference documentation - <ulink
            url="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java"/></para>
          </footnote></para>

        <para>A sample configuration to enable Spring Data repositories looks
        something like this.</para>

        <example>
          <title>Sample annotation based repository configuration</title>

          <programlisting>@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  public EntityManagerFactory entityManagerFactory() {
    // …
  }
}</programlisting>
        </example>

        <note>
          <para>The sample uses the JPA-specific annotation, which you would
          change according to the store module you actually use. The same
          applies to the definition of the
          <interfacename>EntityManagerFactory</interfacename> bean. Consult
          the sections covering the store-specific configuration.</para>
        </note>
      </section>

      <section id="repositories.create-instances.standalone">
        <title>Standalone usage</title>

        <para>You can also use the repository infrastructure outside of a
        Spring container. You still need some Spring libraries in your
        classpath, but generally you can set up repositories programmatically
        as well. The Spring Data modules that provide repository support ship
        a persistence technology-specific
        <classname>RepositoryFactory</classname> that you can use as
        follows.</para>

        <example>
          <title>Standalone usage of repository factory</title>

          <programlisting language="java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);</programlisting>
        </example>
      </section>
    </section>
  </section>

  <section id="repositories.custom-implementations">
    <title>Custom implementations for Spring Data repositories</title>

    <para>Often it is necessary to provide a custom implementation for a few
    repository methods. Spring Data repositories easily allow you to provide
    custom repository code and integrate it with generic CRUD abstraction and
    query method functionality.</para>

    <section id="repositories.single-repository-behaviour">
      <title>Adding custom behavior to single repositories</title>

      <para>To enrich a repository with custom functionality you first define
      an interface and an implementation for the custom functionality. Use the
      repository interface you provided to extend the custom interface.<!--BT None of examples in section 4.1 show JpaRepository. Should they?--></para>

      <example>
        <title>Interface for custom repository functionality</title>

        <programlisting language="java">interface UserRepositoryCustom {

  public void someCustomMethod(User user);
}</programlisting>
      </example>

      <example>
        <title>Implementation of custom repository functionality<!--Would it be helpful to provide an example of a custsom implementation?--></title>

        <para><programlisting language="java">class UserRepositoryImpl implements UserRepositoryCustom {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</programlisting><note>
            <para>The implementation itself does not depend on Spring Data and
            can be a regular Spring bean. So you can use standard dependency
            injection behavior to inject references to other beans, take part
            in aspects, and so on.</para>
          </note></para>
      </example>

      <example>
        <title>Changes to the your basic repository interface</title>

        <para><programlisting language="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt;, UserRepositoryCustom {

  // Declare query methods here
}</programlisting>Let your standard repository interface extend the custom
        one. Doing so makes CRUD and custom functionality available to
        clients.</para>
      </example>

      <simplesect>
        <title>Configuration</title>

        <para>If you use namespace configuration, the repository
        infrastructure tries to autodetect custom implementations by looking
        up classes in the package we found a repository using the naming
        conventions appending the namespace element's attribute
        <code>repository-impl-postfix</code> to the classname. <!--BT Break up preceding into two sentences and clarify wording. Wording doesn't track.-->This
        suffix defaults to <code>Impl</code>.</para>

        <example>
          <title>Configuration example</title>

          <para><programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;repositories base-package="com.acme.repository" repository-impl-postfix="FooBar" /&gt;</programlisting></para>
        </example>

        <para>The first configuration example will try to look up a class
        <classname>com.acme.repository.UserRepositoryImpl</classname> to act
        as custom repository implementation, where the second example will try
        to lookup
        <classname>com.acme.repository.UserRepositoryFooBar</classname>.</para>
      </simplesect>

      <simplesect>
        <title>Manual wiring</title>

        <para>The preceding approach works well if your custom implementation
        uses annotation-based configuration and autowiring only, as it will be
        treated as any other Spring bean. If your custom implementation bean
        needs special wiring, you simply declare the bean and name it after
        the conventions just described. We will then pick up the custom bean
        by name <!--BT preceding, do you need to clarify what you mean by * we will then pick up the custom bean*. What do you do or what 

happens in regard to the custom bean.-->rather than creating an
        instance.</para>

        <example>
          <title>Manual wiring of custom implementations (I)</title>

          <programlisting language="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;beans:bean id="userRepositoryImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/beans:bean&gt;</programlisting>
        </example>
      </simplesect>
    </section>

    <section id="repositories.custom-behaviour-for-all-repositories">
      <title>Adding custom behavior to all repositories</title>

      <para>The preceding approach is not feasible when you want to add a
      single method to all your repository interfaces. <keycap>To add custom
      behavior to all repositories, you first add an intermediate interface to
      declare the shared behavior.</keycap></para>

      <example>
        <title>An interface declaring custom shared behavior</title>

        <para><programlisting language="java">
public interface MyRepository&lt;T, ID extends Serializable&gt;
  extends JpaRepository&lt;T, ID&gt; {

  void sharedCustomMethod(ID id);
}</programlisting></para>
      </example>

      <para>Now your individual repository interfaces will extend this
      intermediate interface instead of the
      <interfacename>Repository</interfacename> interface to include the
      functionality declared.</para>

      <para><keycap>Next, create an implementation of the intermediate
      interface that extends the persistence technology-specific repository
      base class.</keycap> This class will then act as a custom base class for
      the repository proxies.</para>

      <example>
        <title>Custom repository base class</title>

        <programlisting language="java">
public class MyRepositoryImpl&lt;T, ID extends Serializable&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; implements MyRepository&lt;T, ID&gt; {

  private EntityManager entityManager;

  // There are two constructors to choose from, either can be used.
  public MyRepositoryImpl(Class&lt;T&gt; domainClass, EntityManager entityManager) {
    super(domainClass, entityManager);

    // This is the recommended method for accessing inherited class dependencies.
    this.entityManager = entityManager;
  }

  public void sharedCustomMethod(ID id) {
    // implementation goes here
  }
}</programlisting>
      </example>

      <note>
        <para>The default behavior of the Spring <code>&lt;repositories
        /&gt;</code> namespace is to provide an implementation for all
        interfaces that fall under the <code>base-package</code>. This means
        that if left in its current state, an implementation instance of
        <interfacename>MyRepository</interfacename> will be created by Spring.
        This is of course not desired as it is just supposed to act as an
        intermediary between <interfacename>Repository</interfacename> and the
        actual repository interfaces you want to define for each entity. To
        exclude an interface that extends
        <interfacename>Repository</interfacename> from being instantiated as a
        repository instance, you can either annotate it with
        <interfacename>@NoRepositoryBean</interfacename> or move it outside of
        the configured <code>base-package</code>.</para>
      </note>

      <para><keycap>Then create a custom repository factory to replace the
      default <classname>RepositoryFactoryBean</classname> that will in turn
      produce a custom <classname>RepositoryFactory</classname>.</keycap> The
      new repository factory will then provide your
      <classname>MyRepositoryImpl</classname> as the implementation of any
      interfaces that extend the <interfacename>Repository</interfacename>
      interface, replacing the <classname>SimpleJpaRepository</classname>
      implementation you just extended.</para>

      <example>
        <title>Custom repository factory bean</title>

        <programlisting language="java">
public class MyRepositoryFactoryBean&lt;R extends JpaRepository&lt;T, I&gt;, T, I extends Serializable&gt;
  extends JpaRepositoryFactoryBean&lt;R, T, I&gt; {

  protected RepositoryFactorySupport createRepositoryFactory(EntityManager entityManager) {

    return new MyRepositoryFactory(entityManager);
  }

  private static class MyRepositoryFactory&lt;T, I extends Serializable&gt; extends JpaRepositoryFactory {

    private EntityManager entityManager;

    public MyRepositoryFactory(EntityManager entityManager) {
      super(entityManager);

      this.entityManager = entityManager;
    }

    protected Object getTargetRepository(RepositoryMetadata metadata) {

      return new MyRepositoryImpl&lt;T, I&gt;((Class&lt;T&gt;) metadata.getDomainClass(), entityManager);
    }

    protected Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) {

      // The RepositoryMetadata can be safely ignored, it is used by the JpaRepositoryFactory
      //to check for QueryDslJpaRepository's which is out of scope.
      return MyRepository.class;
    }
  }
}</programlisting>
      </example>

      <para><keycap>Finally, either declare beans of the custom factory
      directly or use the <code>factory-class</code> attribute of the Spring
      namespace to tell the repository infrastructure to use your custom
      factory implementation.</keycap></para>

      <example>
        <title>Using the custom factory with the namespace</title>

        <programlisting language="xml">&lt;repositories base-package="com.acme.repository"
  factory-class="com.acme.MyRepositoryFactoryBean" /&gt;</programlisting>
      </example>
    </section>
  </section>

  <section>
    <title>Spring Data extensions</title>

    <para>This section documents a set of Spring Data extensions that enable
    Spring Data usage in a variety of contexts. Currently most of the
    integration is targeted towards Spring MVC.</para>

    <section id="web-domain-class-binding">
      <title>Domain class Web binding for Spring MVC</title>

      <para>Given you are developing a Spring MVC web application you
      typically have to resolve domain class ids from URLs. By default your
      task is to transform that request parameter or URL part into the domain
      class<!--BT, following, last part of this sentence is garbled; revise to clarify wording.-->
      to hand it layers below then or execute business logic on the entities
      directly. This should look something like this:</para>

      <programlisting language="java">@Controller
@RequestMapping("/users")
public class UserController {

  private final UserRepository userRepository;

  @Autowired
  public UserController(UserRepository userRepository) {
    Assert.notNull(repository, "Repository must not be null!");
    userRepository = userRepository;
  }

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") Long id, Model model) {
    
    // Do null check for id
    User user = userRepository.findOne(id);
    // Do null check for user

    model.addAttribute("user", user);
    return "user";
  }
}</programlisting>

      <para>First you declare a repository dependency for each controller to
      look up the entity managed by the controller or repository respectively.
      Looking up the entity is boilerplate as well, as it's always a
      <methodname>findOne(…)</methodname> call. Fortunately Spring provides
      means to register custom components that allow conversion between a
      <classname>String</classname> value to an arbitrary type.</para>

      <simplesect>
        <title>PropertyEditors</title>

        <para>For versions up to Spring 3.0<!--BT if you mean for versions *earlier* than Spring 3.0, say that. If Spring 3.0 and earlier, say that.-->
        simple Java <interfacename>PropertyEditor</interfacename>s had to be
        used. <!--BT preceding, used to do what?-->Spring offers a
        <classname>DomainClassPropertyEditorRegistrar</classname>, which looks
        up all Spring Data repositories registered in the
        <interfacename>ApplicationContext</interfacename> and registers a
        custom <interfacename>PropertyEditor</interfacename> for the managed
        domain class.</para>

        <programlisting language="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
  &lt;property name="webBindingInitializer"&gt;
    &lt;bean class="….web.bind.support.ConfigurableWebBindingInitializer"&gt;
      &lt;property name="propertyEditorRegistrars"&gt;
        &lt;bean class="org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar" /&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

        <para>If you have configured Spring MVC as in the preceding example,
        you can configure your controller as follows, which reduces a lot of
        the clutter and boilerplate.</para>

        <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping("/{id}")
  public String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}</programlisting>
      </simplesect>

      <simplesect>
        <title>ConversionService</title>

        <para>As of Spring 3.0<!--BT Meaning, in Spring 3.0 and later?--> the
        <interfacename>PropertyEditor</interfacename> support is superseded by
        a new conversion infrastructure that eliminates the drawbacks of
        <interfacename>PropertyEditor</interfacename>s and uses a stateless X
        to Y conversion approach. Spring now ships with a
        <classname>DomainClassConverter</classname> that mimics the behavior
        of <classname>DomainClassPropertyEditorRegistrar</classname>. To
        configure, simply declare a bean instance and pipe the
        <interfacename>ConversionService</interfacename> being used into its
        constructor:</para>

        <programlisting language="xml">&lt;mvc:annotation-driven conversion-service="conversionService" /&gt;

&lt;bean class="org.springframework.data.repository.support.DomainClassConverter"&gt;
  &lt;constructor-arg ref="conversionService" /&gt;
&lt;/bean&gt;</programlisting>

        <para>If you are using JavaConfig, you can simply extend
        <classname>WebMvcConfigurationSupport</classname> and hand the
        <classname>FormatingConversionService</classname> that the
        configuration superclass provides into the
        <classname>DomainClassConverter</classname> instance you
        create.</para>

        <programlisting language="java">class WebConfiguration extends WebMvcConfigurationSupport {

  // Other configuration omitted

  @Bean
  public DomainClassConverter&lt;?&gt; domainClassConverter() {
    return new DomainClassConverter&lt;FormattingConversionService&gt;(mvcConversionService());
  }
}</programlisting>
      </simplesect>
    </section>

    <section id="web-pagination">
      <title>Web pagination</title>

      <para><!--BT do you need an intro sentence? what is the example doing? Below, I changed *naive* to *less desirable*.-->The
      less desirable approach shown in the example below requires the method
      to contain an <interfacename>HttpServletRequest</interfacename>
      parameter that has to be parsed manually. This example also omits
      appropriate failure handling, which would make the code even more
      verbose.</para>

      <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  // DI code omitted

  @RequestMapping
  public String showUsers(Model model, HttpServletRequest request) {

    int page = Integer.parseInt(request.getParameter("page"));
    int pageSize = Integer.parseInt(request.getParameter("pageSize"));

    Pageable pageable = new PageRequest(page, pageSize);

    model.addAttribute("users", userService.getUsers(pageable));
    return "users";
  }
}</programlisting>

      <para>The bottom line is that the controller should not have to handle
      the functionality of extracting pagination information from the request.
      So Spring includes a <classname>PageableArgumentResolver</classname>
      that will do the work for you.</para>

      <programlisting language="xml">&lt;bean class="….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
  &lt;property name="customArgumentResolvers"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.data.web.PageableArgumentResolver" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>

      <para>This configuration allows you to simplify controllers down to
      something like this:</para>

      <programlisting lang="" language="java">@Controller
@RequestMapping("/users")
public class UserController {

  @RequestMapping
  public String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", userRepository.findAll(pageable));
    return "users";
  }
}</programlisting>

      <para>The <classname>PageableArgumentResolver</classname> automatically
      resolves request parameters to build a
      <classname>PageRequest</classname> instance. By default it expects the
      following structure for the request parameters.</para>

      <table>
        <title>Request parameters evaluated by
        <classname>PageableArgumentResolver</classname></title>

        <tgroup cols="2">
          <colspec colwidth="1*"/>

          <colspec colwidth="2*"/>

          <tbody>
            <row>
              <entry><code>page</code></entry>

              <entry>Page you want to retrieve.</entry>
            </row>

            <row>
              <entry><code>page.size</code></entry>

              <entry>Size of the page you want to retrieve.</entry>
            </row>

            <row>
              <entry><code>page.sort</code></entry>

              <entry>Property that should be sorted by.<!--BT Does preceding read ok?--></entry>
            </row>

            <row>
              <entry><code>page.sort.dir</code></entry>

              <entry>Direction that should be used for sorting.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In case you need multiple <interfacename>Pageable</interfacename>s
      to be resolved from the request (for multiple tables, for example) you
      can use Spring's <interfacename>@Qualifier</interfacename> annotation to
      distinguish one from another. The request parameters then have to be
      prefixed with <code>${qualifier}_</code>. So for a method signature like
      this:</para>

      <programlisting lang="" language="java">public String showUsers(Model model, 
      @Qualifier("foo") Pageable first,
      @Qualifier("bar") Pageable second) { … }
</programlisting>

      <para>you have to populate <code>foo_page</code> and
      <code>bar_page</code> and the related subproperties.</para>

      <simplesect>
        <title>Configuring a global default on bean declaration</title>

        <para>The <classname>PageableArgumentResolver</classname> will use a
        <classname>PageRequest</classname> with the first page and a page size
        of 10 by default. It will use that value if it cannot resolve a
        <classname>PageRequest</classname> from the request (because of
        missing parameters, for example). You can configure a global default
        on the bean declaration directly. If you might need controller method
        specific defaults for the <interfacename>Pageable</interfacename>,
        annotate the method parameter with
        <interfacename>@PageableDefaults</interfacename> and specify page
        (through <code>pageNumber</code>), page size (through
        <code>value</code>), <code>sort</code> (list of properties to sort
        by), and <code>sortDir</code> (the direction to sort by) as annotation
        attributes:<!--BT Preceding sentence: Parameter names are different than in table above. OK? ( page.size vs. value, page.sort.dir vs. sortDir)--></para>

        <programlisting lang="" language="java">public String showUsers(Model model, 
  @PageableDefaults(pageNumber = 0, value = 30) Pageable pageable) { … }</programlisting>
      </simplesect>
    </section>

    <section>
      <title>Repository populators</title>

      <para>If you work with the Spring JDBC module, you probably are familiar
      with the support to populate a DataSource using SQL scripts. A similar
      abstraction is available on the repositories level, although Spring does
      not use SQL as the data definition language because it must be
      store-independent. Thus the populators support XML (through Spring's OXM
      abstraction) and JSON (through Jackson) to define data with which to
      populate the repositories.</para>

      <para>Assume you have a file <filename>data.json</filename> with the
      following content:</para>

      <example>
        <title>Data defined in JSON</title>

        <programlisting>[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]</programlisting>
      </example>

      <para>You can easily populate your repositories by using the populator
      elements of the repository namespace provided in Spring Data Commons. To
      populate the preceding data to your
      <interfacename>PersonRepository</interfacename> , do the
      following:</para>

      <example>
        <title>Declaring a Jackson repository populator</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

  &lt;repository:jackson-populator location="classpath:data.json" /&gt;

&lt;/beans&gt;</programlisting>
      </example>

      <para>This declaration causes the data.json file being read,
      deserialized by a Jackson <classname>ObjectMapper</classname>. <!--BT Preceding, reword; wording doesn't track.-->The
      type to which the JSON object will be unmarshalled will be determined by
      inspecting the <code>_class</code> attribute of the JSON document. We
      will eventually select the appropriate repository to handle the object
      just deserialized.<!--BT preceding, by *eventually* do you mean this will be shown in a later section? If so, indicate section. --></para>

      <para>To rather use XML to define the repositories shall be populated
      with you can use the unmarshaller-populator you hand one of the
      marshaller options Spring OXM provides you with.<!--BT preceding, wording is somewhat garbled. Reword.--></para>

      <example>
        <title>Declaring an unmarshalling repository populator (using
        JAXB)</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    http://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    http://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

  &lt;repository:unmarshaller-populator location="classpath:data.json" unmarshaller-ref="unmarshaller" /&gt;

  &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

&lt;/beans&gt;</programlisting>
      </example>
    </section>
  </section>
</chapter>
